FORMAT: 1A
HOST: http://alde.tango-project.eu/api/v1

# Application Lifecycle Deployment Engine

The Application Lifecycle Deployment Engine is a component of the TANGO project: http://www.tango-project.eu .

It will be responsible of informing about the hetegoregenous resources in the different testbeds. Also, it will collect the application as input, compile it to the targetted testbed and, if possible, execute it.

The Application Lifececyle Deployment Engine is being developed by Atos Research and Innovation and its code it is being relased under an Apache 2.0 license: https://www.apache.org/licenses/LICENSE-2.0

## Testbeds [/testbeds?{page,results_per_page}]

### List all testbeds [GET]

The response is paginated. By default it shows the 10 first results, you can ask for next pages via query params. It is also possible to limit the size of the page response.

+ Parameters
  + page (number, optional) - Specifies the page of results the client wants to see
  + results_per_page (number, optional) - Limits the number of results per each page

+ Response 200 (application/json)

        {
          "num_results": 11,
          "objects": [
            {
              "category": "embedded",
              "endpoint": "compiled_to_disk",
              "id": 1,
              "name": "Testbed_1",
              "nodes": [],
              "on_line": true,
              "protocol": "none"
            },
            {
              "category": "embedded",
              "endpoint": "compiled_to_disk",
              "id": 2,
              "name": "Testbed_1",
              "nodes": [],
              "on_line": false,
              "protocol": "none"
            },
            {
              "category": "embedded",
              "endpoint": "compiled_to_disk",
              "id": 3,
              "name": "Testbed_3",
              "nodes": [],
              "on_line": false,
              "protocol": "none"
            },
            {
              "category": "embedded",
              "endpoint": "compiled_to_disk",
              "id": 4,
              "name": "Testbed_4",
              "nodes": [],
              "on_line": false,
              "protocol": "none"
            },
            {
              "category": "embedded",
              "endpoint": "compiled_to_disk",
              "id": 5,
              "name": "Testbed_5",
              "nodes": [],
              "on_line": false,
              "protocol": "none"
            },
            {
              "category": "embedded",
              "endpoint": "compiled_to_disk",
              "id": 6,
              "name": "Testbed_6",
              "nodes": [],
              "on_line": false,
              "protocol": "none"
            },
            {
              "category": "embedded",
              "endpoint": "compiled_to_disk",
              "id": 7,
              "name": "Testbed_7",
              "nodes": [],
              "on_line": false,
              "protocol": "none"
            },
            {
              "category": "embedded",
              "endpoint": "compiled_to_disk",
              "id": 8,
              "name": "Testbed_8",
              "nodes": [],
              "on_line": false,
              "protocol": "none"
            },
            {
              "category": "embedded",
              "endpoint": "compiled_to_disk",
              "id": 9,
              "name": "Testbed_9",
              "nodes": [],
              "on_line": false,
              "protocol": "none"
            },
            {
              "category": "embedded",
              "endpoint": "compiled_to_disk",
              "id": 10,
              "name": "Testbed_10",
              "nodes": [],
              "on_line": false,
              "protocol": "none"
            }
          ],
          "page": 1,
          "total_pages": 2
        }


### Create a new testbed [POST]

+ Request (application/json)

        {
          "name" : "Testbed_11",
          "on_line" : false,
          "category" : "embedded",
          "protocol" : "none",
          "endpoint" : "compiled_to_disk"
        }

+ Response 201 (application/json)

        {
          "category": "embedded",
          "endpoint": "compiled_to_disk",
          "id": 12,
          "name": "Testbed_11",
          "nodes": [],
          "on_line": false,
          "protocol": "none"
        }

## Testbed [/testbeds/{testbed_id}]

+ Parameters
    + testbed_id (number) - ID of the testbed in the form of an integer

### View a testbed details [GET]

+ Response 200 (application/json)

        {
          "category": "embedded",
          "endpoint": "compiled_to_disk",
          "id": testbed_id,
          "name": "Testbed_11",
          "nodes": [],
          "on_line": false,
          "protocol": "none"
        }

### Update of testbed details [PUT]

+ Request (application/json)

        {
            name: "Testbed_12",
        }

+ Response 200 (application/json)

        {
          "category": "embedded",
          "endpoint": "compiled_to_disk",
          "id": testbed_id,
          "name": "Testbed_12",
          "nodes": [],
          "on_line": false,
          "protocol": "none"
        }

### Delete of testbed detailes [DELETE]

This will delete the testbed from the ALDE database together with all the node information associated to that testbed
of
+ Response 204

### Add a node to the testbed [PATCH]

It can be used to add nodes to a testbed. The testbed is only going to allow a node to be added if this testbed is not of the on-line type.

+ Request (application/json)

        {
            "nodes" : {
                "add": [
                  {
                    "name" : "node_3",
                    "information_retrieved" : false
                  }
                ]
            }
        }

+ Response 200

        {
          "category": "embedded",
          "endpoint": "compiled_to_disk",
          "id": 11,
          "name": "Testbed_11",
          "nodes": [
            {
              "id": 1,
              "information_retrieved": false,
              "name": "node_3",
              "testbed_id": 11
            }
          ],
          "on_line": false,
          "protocol": "none"
        }

+ Request (application/json)

        {
            "nodes" : {
                "add": [
                  {
                    "id" : 1
                  }
                ]
            }
        }

+ Response 200

        {
          "category": "embedded",
          "endpoint": "compiled_to_disk",
          "id": 11,
          "name": "Testbed_11",
          "nodes": [
            {
              "id": 1,
              "information_retrieved": false,
              "name": "node_3",
              "testbed_id": 11
            }
          ],
          "on_line": false,
          "protocol": "none"
        }

## Nodes in a testbed [/testbeds/{testbed_id}/nodes?page={page},results_per_page={results_per_page}]

As in the previous cases, the response is paginated:

+ Parameters
    + testbed_id (number) - ID of the testbed in the form of an integer
    + page (number, optional) - Specifies the page of results the client wants to see
    + results_per_page (number, optional) - Limits the number of results per each page

### List all nodes of a testbed [GET]

+ Response 200 (application/json)

        {
          "num_results": 3,
          "objects": [
            {
              "cpus": [],
              "gpus": [],
              "id": 1,
              "information_retrieved": false,
              "memories": [],
              "name": "node_3",
              "testbed": {
                "category": "embedded",
                "endpoint": "compiled_to_disk",
                "id": 11,
                "name": "Testbed_11",
                "on_line": false,
                "protocol": "none"
              },
              "testbed_id": 11
            },
            {
              "cpus": [],
              "gpus": [],
              "id": 2,
              "information_retrieved": false,
              "memories": [],
              "name": "node_4",
              "testbed": {
                "category": "embedded",
                "endpoint": "compiled_to_disk",
                "id": 11,
                "name": "Testbed_11",
                "on_line": false,
                "protocol": "none"
              },
              "testbed_id": 11
            },
            {
              "cpus": [],
              "gpus": [],
              "id": 3,
              "information_retrieved": false,
              "memories": [],
              "name": "node_5",
              "testbed": {
                "category": "embedded",
                "endpoint": "compiled_to_disk",
                "id": 11,
                "name": "Testbed_11",
                "on_line": false,
                "protocol": "none"
              },
              "testbed_id": 11
            }
          ],
          "page": 1,
          "total_pages": 1
        }

### Nodes [/nodes?page={page},results_per_page={results_per_page}]

As in the previous cases, the response is paginated:

+ Parameters
    + page (number, optional) - Specifies the page of results the client wants to see
    + results_per_page (number, optional) - Limits the number of results per each page

### List all nodes of a testbed [GET]

+ Response 200 (application/json)

        {
          "num_results": 3,
          "objects": [
            {
              "cpus": [],
              "gpus": [],
              "id": 1,
              "information_retrieved": false,
              "memories": [],
              "name": "node_3",
              "testbed": {
                "category": "embedded",
                "endpoint": "compiled_to_disk",
                "id": 11,
                "name": "Testbed_11",
                "on_line": false,
                "protocol": "none"
              },
              "testbed_id": 11
            },
            {
              "cpus": [],
              "gpus": [],
              "id": 2,
              "information_retrieved": false,
              "memories": [],
              "name": "node_4",
              "testbed": {
                "category": "embedded",
                "endpoint": "compiled_to_disk",
                "id": 11,
                "name": "Testbed_11",
                "on_line": false,
                "protocol": "none"
              },
              "testbed_id": 11
            },
            {
              "cpus": [],
              "gpus": [],
              "id": 3,
              "information_retrieved": false,
              "memories": [],
              "name": "node_5",
              "testbed": {
                "category": "embedded",
                "endpoint": "compiled_to_disk",
                "id": 11,
                "name": "Testbed_11",
                "on_line": false,
                "protocol": "none"
              },
              "testbed_id": 11
            }
          ],
          "page": 1,
          "total_pages": 1
        }

### Create a new node in a testbed [POST]

This is only possible for testbed where the node information is not gotten directly using some probes.

+ Request (application/json)

        {
          "name" : "node_3",
          "information_retrieved" : false
        }

+ Response 201 (application/json)

        {
          "cpus": [],
          "gpus": [],
          "id": 4,
          "information_retrieved": false,
          "memories": [],
          "name": "node_3",
          "testbed": null,
          "testbed_id": null
        }

## Nodes [/nodes/{node_id}]

+ Parameters
    + node_id (number) - ID of the node from the testbed in the form of an integer

### List the node information [GET]

+ Response 200 (application/json)

          {
            "cpus": [],
            "gpus": [],
            "id": 4,
            "information_retrieved": false,
            "memories": [],
            "name": "node_3",
            "testbed": null,
            "testbed_id": null
          }

### Updates the information of a node [PUT]
This only works with nodes that have the variable "information_retrieved" set to "manually".

+ Request (application/json)

        {
          "name" : "node_5"
        }

+ Response 200 (application/json)

        {
          "cpus": [],
          "gpus": [],
          "id": 4,
          "information_retrieved": false,
          "memories": [],
          "name": "node_5",
          "testbed": null,
          "testbed_id": null
        }

### Deletion of a node [DELETE]
This only works with nodes that have the variable "information_retrieved" set to "manually".

+ Response 204

### Modification of the resources node [PATCH]

With this action is possible to add GPUs, CPUs, MCPs, or other hardware components to a node

It includes examples about how to add a CPU, GPU, MCP or Memory to a node

+ Request (application/json)

        {
          "cpus" :
            {
              "add" :
                [
                  {
                    "vendor_id" : "GenuineIntel",
                    "model_name" : "Intel(R) Xeon(R) CPU           E5630  @ 2.53GHz",
                    "arch" : "x86_64",
                    "model" : "44",
                    "speed" : "2527.198 Mhz",
                    "fpu" : true,
                    "cores" : 4,
                    "cache" : "12288 KB",
                    "flags" : "fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon pebs bts rep_good nopl xtopology nonstop_tsc aperfmperf pni pclmulqdq dtes64 monitor ds_cpl vmx smx est tm2 ssse3 cx16 xtpr pdcm pcid dca sse4_1 sse4_2 popcnt aes lahf_lm ida arat dtherm tpr_shadow vnmi flexpriority ept vpid"
                  }
                ]
              }
          }

+ Response 200 (application/json)

        {
          "cpus": [
            {
              "arch": "x86_64",
              "cache": "12288 KB",
              "cores": 4,
              "flags": "fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon pebs bts rep_good nopl xtopology nonstop_tsc aperfmperf pni pclmulqdq dtes64 monitor ds_cpl vmx smx est tm2 ssse3 cx16 xtpr pdcm pcid dca sse4_1 sse4_2 popcnt aes lahf_lm ida arat dtherm tpr_shadow vnmi flexpriority ept vpid",
              "fpu": true,
              "id": 1,
              "model": "44",
              "model_name": "Intel(R) Xeon(R) CPU           E5630  @ 2.53GHz",
              "node_id": 4,
              "speed": "2527.198 Mhz",
              "vendor_id": "GenuineIntel"
            }
          ],
          "gpus": [],
          "id": 4,
          "information_retrieved": false,
          "memories": [],
          "name": "node_5",
          "testbed": null,
          "testbed_id": null
        }

+ Request (application/json)

        {
          "memories":
            {
              "add" :
                [
                  {
                    "size" : "4096",
                    "units" : "MB",
                    "address" : "",
                    "memory_type" : "DDR3"
                  },
                  {
                    "size" : "4096",
                    "units" : "MB",
                    "address" : "",
                    "memory_type" : "DDR3"
                  }
                ]
              }
          }

+ Response 200 (application/json)

        {
          "cpus": [
            {
              "arch": "x86_64",
              "cache": "12288 KB",
              "cores": 4,
              "flags": "fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon pebs bts rep_good nopl xtopology nonstop_tsc aperfmperf pni pclmulqdq dtes64 monitor ds_cpl vmx smx est tm2 ssse3 cx16 xtpr pdcm pcid dca sse4_1 sse4_2 popcnt aes lahf_lm ida arat dtherm tpr_shadow vnmi flexpriority ept vpid",
              "fpu": true,
              "id": 1,
              "model": "44",
              "model_name": "Intel(R) Xeon(R) CPU           E5630  @ 2.53GHz",
              "node_id": 4,
              "speed": "2527.198 Mhz",
              "vendor_id": "GenuineIntel"
            }
          ],
            "gpus": [],
            "id": 4,
            "information_retrieved": false,
            "memories": [
              {
                "address": "",
                "id": 1,
                "memory_type": "DDR3",
                "node_id": 4,
                "size": 4096,
                "units": "MB"
              },
              {
                "address": "",
                "id": 2,
                "memory_type": "DDR3",
                "node_id": 4,
                "size": 4096,
                "units": "MB"
              }
            ],
            "name": "node_5",
            "testbed": null,
            "testbed_id": null
          }



## Applications [/applications]

### List all applications [GET]

+ Response 200 (application/json)

        [
            {
                id: 0,
                name: "APP_NAME",
                status: "building",
                path_to_code: "path_to_code",
                build: {
                    build_Script: "path_to_script",
                    build_script_parameters: "XXXXX"
                },
                package: [
                    docker: {
                        xxx: "aaa",
                        yyy: "aaa"
                    },
                    executable: {
                        xxx: "aaa",
                        yyy: "yyy"
                    }
                ],
                execution: {
                    execution_command: "XXXXX",
                    execution_command_params: "YYYYY",
                    execution_status: {
                        slurm: {
                            see_which_information_provides_sluem: "XXX"
                        }
                    }
                }
            },
            {
                id: 1,
                name: "APP_NAME",
                status: "building",
                path_to_code: "path_to_code",
                build: {
                    build_Script: "path_to_script",
                    build_script_parameters: "XXXXX"
                },
                package: [
                    docker: {
                        xxx: "aaa",
                        yyy: "aaa"
                    },
                    executable: {
                        xxx: "aaa",
                        yyy: "yyy"
                    }
                ],
                execution: {
                    execution_command: "XXXXX",
                    execution_command_params: "YYYYY",
                    execution_status: {
                        slurm: {
                            see_which_information_provides_sluem: "XXX"
                        }
                    }
                }
            }
        ]

### Create a new application [POST]


+ Request (application/json)

        {
            name: "APP_NAME",
            status: "building",
            path_to_code: "path_to_code",
            build: {
                build_Script: "path_to_script",
                build_script_parameters: "XXXXX"
            },
            package: [
                docker: {
                    xxx: "aaa",
                    yyy: "aaa"
                },
                executable: {
                    xxx: "aaa",
                    yyy: "yyy"
                }
            ],
            execution: {
                execution_command: "XXXXX",
                execution_command_params: "YYYYY",
                execution_status: {
                    slurm: {
                        see_which_information_provides_sluem: "XXX"
                    }
                }
            }
        }

+ Response 201 (application/json)

        {
            id: 1,
            name: "APP_NAME",
            status: "building",
            path_to_code: "path_to_code",
            build: {
                build_Script: "path_to_script",
                build_script_parameters: "XXXXX"
            },
            package: [
                docker: {
                    xxx: "aaa",
                    yyy: "aaa"
                },
                executable: {
                    xxx: "aaa",
                    yyy: "yyy"
                }
            ],
            execution: {
                execution_command: "XXXXX",
                execution_command_params: "YYYYY",
                execution_status: {
                    slurm: {
                        see_which_information_provides_sluem: "XXX"
                    }
                }
            }
        }

## Application [/applications/{application_id}]

+ Parameters
    + application_id (number) - ID of the application in the form of an integer

### Get the information of an application [GET]

+ Response 200 (application/json)

        {
            id: 1,
            name: "APP_NAME",
            status: "building",
            path_to_code: "path_to_code",
            build: {
                build_Script: "path_to_script",
                build_script_parameters: "XXXXX"
            },
            package: [
                docker: {
                    xxx: "aaa",
                    yyy: "aaa"
                },
                executable: {
                    xxx: "aaa",
                    yyy: "yyy"
                }
            ],
            execution: {
                execution_command: "XXXXX",
                execution_command_params: "YYYYY",
                execution_status: {
                    slurm: {
                        see_which_information_provides_sluem: "XXX"
                    }
                }
            }
        }

### Update the state of an application [PUT]

+ Request (application/json)

        {
            status: "compile"
        }

+ Response 200 (application/json)

        {
            id: 2,
            name: "APP_NAME",
            status: "compiling",
            path_to_code: "path_to_code",
            build: {
                build_Script: "path_to_script",
                build_script_parameters: "XXXXX"
            },
            package: [
                docker: {
                    xxx: "aaa",
                    yyy: "aaa"
                },
                executable: {
                    xxx: "aaa",
                    yyy: "yyy"
                }
            ],
            execution: {
                execution_command: "XXXXX",
                execution_command_params: "YYYYY",
                execution_status: {
                    slurm: {
                        see_which_information_provides_sluem: "XXX"
                    }
                }
            }
        }


### Removing an application from ALDE [DELETE]

This basically unregisters the application from ALDE. Depending on the testbed, it will also means to remove the application from the testbed.

+ Response 204